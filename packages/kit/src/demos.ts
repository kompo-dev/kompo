/**
 * Demo and Provider utilities for Kompo CLI
 * Handles registration and index generation for demo components and providers
 */

import path from 'node:path'
import type { KompoContext } from './context'
import { readKompoConfig } from './kompo-config'

export interface DemoMeta {
  id: string
  name: string
  icon: string
  description: string
  order?: number
}

export interface ProviderMeta {
  id: string
  name: string
  order: number
}

interface FrameworkPaths {
  demosDir: string
  providersDir: string
  providersIndexPath: string
}

/**
 * Get framework-specific paths for demos and providers
 */
export function getFrameworkPaths(targetDir: string, framework: 'nextjs' | 'vite'): FrameworkPaths {
  if (framework === 'nextjs') {
    return {
      demosDir: path.join(targetDir, 'src', 'components', 'demos'),
      providersDir: path.join(targetDir, 'src', 'providers'),
      providersIndexPath: path.join(targetDir, 'src', 'app', 'providers.tsx'),
    }
  }
  // vite / react
  return {
    demosDir: path.join(targetDir, 'src', 'components', 'demos'),
    providersDir: path.join(targetDir, 'src', 'providers'),
    providersIndexPath: path.join(targetDir, 'src', 'providers', 'index.tsx'),
  }
}

/**
 * Detect the framework from kompo.config.json
 */
export async function detectFramework(ctx: KompoContext): Promise<'nextjs' | 'vite'> {
  const repoRoot = path.dirname(path.dirname(ctx.targetDir))
  const config = readKompoConfig(repoRoot)

  if (!config) return 'nextjs' // default

  // Find the app config for current targetDir
  for (const [appPath, appConfig] of Object.entries(config.apps)) {
    if (ctx.targetDir.includes(appPath)) {
      return appConfig.frontend as 'nextjs' | 'vite'
    }
  }

  return 'nextjs'
}

/**
 * Register a demo component for a port
 */
export async function registerDemo(
  ctx: KompoContext,
  meta: DemoMeta,
  componentContent: string
): Promise<void> {
  const framework = await detectFramework(ctx)
  const paths = getFrameworkPaths(ctx.targetDir, framework)
  const { fs } = ctx

  // Ensure demos directory exists
  await fs.ensureDir(paths.demosDir)

  // Write the demo component
  const componentFileName = `${capitalizeFirst(meta.id)}Demo.tsx`
  const componentPath = path.join(paths.demosDir, componentFileName)
  await fs.writeFile(componentPath, componentContent)

  // Write meta.json for this demo
  const metaPath = path.join(paths.demosDir, `${meta.id}.meta.json`)
  await fs.writeFile(metaPath, JSON.stringify(meta, null, 2))

  // Regenerate the demos index
  await regenerateDemosIndex(ctx)
}

/**
 * Register a provider for a port
 */
export async function registerProvider(
  ctx: KompoContext,
  meta: ProviderMeta,
  providerContent: string
): Promise<void> {
  const framework = await detectFramework(ctx)
  const paths = getFrameworkPaths(ctx.targetDir, framework)
  const { fs } = ctx

  // Ensure providers directory exists
  await fs.ensureDir(paths.providersDir)

  // Write the provider component
  const providerFileName = `${meta.id}-provider.tsx`
  const providerPath = path.join(paths.providersDir, providerFileName)
  await fs.writeFile(providerPath, providerContent)

  // Write meta.json for this provider
  const metaPath = path.join(paths.providersDir, `${meta.id}.meta.json`)
  await fs.writeFile(metaPath, JSON.stringify(meta, null, 2))

  // Regenerate the providers index
  await regenerateProvidersIndex(ctx)
}

/**
 * Regenerate the demos/index.ts file by scanning meta.json files
 */
export async function regenerateDemosIndex(ctx: KompoContext): Promise<void> {
  const framework = await detectFramework(ctx)
  const paths = getFrameworkPaths(ctx.targetDir, framework)
  const { fs } = ctx

  if (!(await fs.fileExists(paths.demosDir))) return

  // Scan for meta.json files
  const files = await fs.readDir(paths.demosDir)
  const metaFiles = files.filter((f) => f.endsWith('.meta.json'))

  const demos: DemoMeta[] = []
  for (const metaFile of metaFiles) {
    const metaPath = path.join(paths.demosDir, metaFile)
    const content = await fs.readFile(metaPath)
    try {
      demos.push(JSON.parse(content) as DemoMeta)
    } catch {
      // Skip invalid meta files
    }
  }

  // Sort by order, then by name
  demos.sort((a, b) => (a.order ?? 100) - (b.order ?? 100))

  // Generate index.ts content
  const imports = demos
    .map((d) => `import { ${capitalizeFirst(d.id)}Demo } from './${capitalizeFirst(d.id)}Demo'`)
    .join('\n')

  const registryEntries = demos
    .map(
      (d) =>
        `  ${d.id}: { component: ${capitalizeFirst(d.id)}Demo, name: '${d.name}', icon: '${d.icon}', description: '${d.description}' },`
    )
    .join('\n')

  const indexContent = `// @generated by Kompo CLI - regenerate with: kompo generate
// DO NOT EDIT - changes will be overwritten

${imports}

export const demoRegistry = {
${registryEntries}
} as const

export type DemoId = keyof typeof demoRegistry
`

  const indexPath = path.join(paths.demosDir, 'index.ts')
  await fs.writeFile(indexPath, indexContent)
}

/**
 * Regenerate the providers index file by scanning meta.json files
 */
export async function regenerateProvidersIndex(ctx: KompoContext): Promise<void> {
  const framework = await detectFramework(ctx)
  const paths = getFrameworkPaths(ctx.targetDir, framework)
  const { fs } = ctx

  if (!(await fs.fileExists(paths.providersDir))) return

  // Scan for meta.json files
  const files = await fs.readDir(paths.providersDir)
  const metaFiles = files.filter((f) => f.endsWith('.meta.json'))

  const providers: ProviderMeta[] = []
  for (const metaFile of metaFiles) {
    const metaPath = path.join(paths.providersDir, metaFile)
    const content = await fs.readFile(metaPath)
    try {
      providers.push(JSON.parse(content) as ProviderMeta)
    } catch {
      // Skip invalid meta files
    }
  }

  // Sort by order (lower = outer wrapper)
  providers.sort((a, b) => a.order - b.order)

  if (providers.length === 0) {
    // No providers, create a passthrough
    const indexContent = `// @generated by Kompo CLI - regenerate with: kompo generate
// DO NOT EDIT - changes will be overwritten

'use client'

export function Providers({ children }: { children: React.ReactNode }) {
  return <>{children}</>
}
`
    await fs.writeFile(paths.providersIndexPath, indexContent)
    return
  }

  // Generate imports
  const imports = providers
    .map((p) => `import { ${capitalizeFirst(p.id)}Provider } from './${p.id}-provider'`)
    .join('\n')

  // Generate nested providers (first = outermost)
  const indent = '      '
  let nested = '{children}'
  for (let i = providers.length - 1; i >= 0; i--) {
    const p = providers[i]
    const providerName = `${capitalizeFirst(p.id)}Provider`
    if (i === providers.length - 1) {
      nested = `<${providerName}>{children}</${providerName}>`
    } else {
      nested = `<${providerName}>\n${indent}  ${nested}\n${indent}</${providerName}>`
    }
  }

  const indexContent = `// @generated by Kompo CLI - regenerate with: kompo generate
// DO NOT EDIT - changes will be overwritten

'use client'

${imports}

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    ${nested}
  )
}
`

  await fs.writeFile(paths.providersIndexPath, indexContent)
}

/**
 * Regenerate both demos and providers indexes
 */
export async function regenerateAllIndexes(ctx: KompoContext): Promise<void> {
  await regenerateDemosIndex(ctx)
  await regenerateProvidersIndex(ctx)
}

function capitalizeFirst(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1)
}
