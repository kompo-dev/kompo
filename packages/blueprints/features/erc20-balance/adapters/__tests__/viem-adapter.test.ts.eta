import { describe, it, expect, vi, beforeEach } from 'vitest'
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'
import { viemTokenBalanceReader } from '../viem-<%= it.domain %>-adapter'
import type { TokenBalanceReader } from '../../../domains/<%= it.domain %>/ports'

// Mock viem client
vi.mock('viem', () => ({
  createPublicClient: vi.fn(),
  http: vi.fn(),
}))

describe('Viem <%= it.pascalDomain %> Adapter', () => {
  let mockClient: any
  let tokenBalanceReader: TokenBalanceReader

  beforeEach(() => {
    // Setup mock client
    mockClient = {
      readContract: vi.fn(),
      getDecimals: vi.fn(),
      getSymbol: vi.fn(),
    }

    // Mock createPublicClient to return our mock
    vi.mocked(createPublicClient).mockReturnValue(mockClient)

    // Create the adapter
    tokenBalanceReader = viemTokenBalanceReader(mockClient as any)
  })

  describe('viemTokenBalanceReader', () => {
    it('should read balance from ERC20 contract', async () => {
      // Arrange
      const balance = 1000000n
      const decimals = 6
      const symbol = 'USDC'
      
      mockClient.readContract
        .mockResolvedValueOnce(balance) // balance
        .mockResolvedValueOnce(decimals) // decimals
        .mockResolvedValueOnce(symbol) // symbol

      const input = {
        address: '0x1234567890123456789012345678901234567890' as const,
        token: '0xabcdefabcdefabcdefabcdefabcdefabcdefabcd' as const,
      }

      // Act
      const result = await tokenBalanceReader(input)

      // Assert
      expect(result).toEqual({
        balance,
        formatted: '1.0', // 1000000 / 10^6
        decimals,
        symbol,
      })

      expect(mockClient.readContract).toHaveBeenCalledWith({
        address: input.token,
        abi: expect.any(Array), // ERC20 ABI
        functionName: 'balanceOf',
        args: [input.address],
      })
    })

    it('should handle zero decimals correctly', async () => {
      // Arrange
      const balance = 42n
      const decimals = 0
      const symbol = 'WHOLE'
      
      mockClient.readContract
        .mockResolvedValueOnce(balance)
        .mockResolvedValueOnce(decimals)
        .mockResolvedValueOnce(symbol)

      const input = {
        address: '0x1234567890123456789012345678901234567890' as const,
        token: '0xabcdefabcdefabcdefabcdefabcdefabcdefabcd' as const,
      }

      // Act
      const result = await tokenBalanceReader(input)

      // Assert
      expect(result.formatted).toBe('42') // No decimal places
    })

    it('should handle contract read errors gracefully', async () => {
      // Arrange
      const error = new Error('Contract read failed')
      mockClient.readContract.mockRejectedValue(error)

      const input = {
        address: '0x1234567890123456789012345678901234567890' as const,
        token: '0xabcdefabcdefabcdefabcdefabcdefabcdefabcd' as const,
      }

      // Act & Assert
      await expect(tokenBalanceReader(input)).rejects.toThrow('Contract read failed')
    })

    it('should handle invalid token address', async () => {
      // Arrange
      mockClient.readContract.mockRejectedValue(new Error('Invalid contract address'))

      const input = {
        address: '0x1234567890123456789012345678901234567890' as const,
        token: '0x0000000000000000000000000000000000000000' as const,
      }

      // Act & Assert
      await expect(tokenBalanceReader(input)).rejects.toThrow()
    })
  })
})
